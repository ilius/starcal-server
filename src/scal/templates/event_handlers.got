// if this is a *.go file, don't modify it, it's auto-generated
// from a Django template file named `*.got` inside "templates" directory
package api_v1

import (
	"fmt"
	"strings"
	"time"
	//"log"
	"crypto/sha1"
	"encoding/json"
	"gopkg.in/mgo.v2/bson"
	"io/ioutil"
	"net"
	"net/http"
	"reflect"

	//"github.com/gorilla/mux"

	"scal"
	"scal/event_lib"
	"scal/settings"
	"scal/storage"
)

func init() {
	routeGroups = append(routeGroups, RouteGroup{
		Base: "event/{{.EVENT_TYPE}}",
		Map: RouteMap{
			"Add{{.CAP_EVENT_TYPE}}": {
				Method: "POST",
				Pattern: "",
				HandlerFunc: authWrap(Add{{.CAP_EVENT_TYPE}}),
			},
			"Get{{.CAP_EVENT_TYPE}}": {
				Method: "GET",
				Pattern: "{eventId}",
				HandlerFunc: authWrap(Get{{.CAP_EVENT_TYPE}}),
			},
			"Update{{.CAP_EVENT_TYPE}}": {
				Method: "PUT",
				Pattern: "{eventId}",
				HandlerFunc: authWrap(Update{{.CAP_EVENT_TYPE}}),
			},
			"Patch{{.CAP_EVENT_TYPE}}": {
				Method: "PATCH",
				Pattern: "{eventId}",
				HandlerFunc: authWrap(Patch{{.CAP_EVENT_TYPE}}),
			},
			"Merge{{.CAP_EVENT_TYPE}}": {
				Method: "POST",
				Pattern: "{eventId}/merge",
				HandlerFunc: authWrap(Merge{{.CAP_EVENT_TYPE}}),
			},
			// functions of following operations are defined in handlers.go
			// because their definition does not depend on event type
			// but their URL still contains eventType for sake of compatibilty
			// so we will have to register their routes for each event type
			// we don't use eventType in these functions
			"DeleteEvent_{{.EVENT_TYPE}}": {
				Method: "DELETE",
				Pattern: "{eventId}",
				HandlerFunc: authWrap(DeleteEvent),
			},
			"SetEventGroupId_{{.EVENT_TYPE}}": {
				Method: "PUT",
				Pattern: "{eventId}/group",
				HandlerFunc: authWrap(SetEventGroupId),
			},
			"GetEventOwner_{{.EVENT_TYPE}}": {
				Method: "GET",
				Pattern: "{eventId}/owner",
				HandlerFunc: authWrap(GetEventOwner),
			},
			"SetEventOwner_{{.EVENT_TYPE}}": {
				Method: "PUT",
				Pattern: "{eventId}/owner",
				HandlerFunc: authWrap(SetEventOwner),
			},
			"GetEventMeta_{{.EVENT_TYPE}}": {
				Method: "GET",
				Pattern: "{eventId}/meta",
				HandlerFunc: authWrap(GetEventMeta),
			},
			"GetEventAccess_{{.EVENT_TYPE}}": {
				Method: "GET",
				Pattern: "{eventId}/access",
				HandlerFunc: authWrap(GetEventAccess),
			},
			"SetEventAccess_{{.EVENT_TYPE}}": {
				Method: "PUT",
				Pattern: "{eventId}/access",
				HandlerFunc: authWrap(SetEventAccess),
			},
			"AppendEventAccess_{{.EVENT_TYPE}}": {
				Method: "POST",
				Pattern: "{eventId}/access",
				HandlerFunc: authWrap(AppendEventAccess),
			},
			"JoinEvent_{{.EVENT_TYPE}}": {
				Method: "GET",
				Pattern: "{eventId}/join",
				HandlerFunc: authWrap(JoinEvent),
			},
			"LeaveEvent_{{.EVENT_TYPE}}": {
				Method: "GET",
				Pattern: "{eventId}/leave",
				HandlerFunc: authWrap(LeaveEvent),
			},
			"InviteToEvent_{{.EVENT_TYPE}}": {
				Method: "POST",
				Pattern: "{eventId}/invite",
				HandlerFunc: authWrap(InviteToEvent),
			},
		},
	})
}

func Add{{.CAP_EVENT_TYPE}}(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	userModel := CheckAuthGetUserModel(w, r)
	if userModel == nil {
		return
	}
	email := userModel.Email
	// -----------------------------------------------
	eventModel := event_lib.{{.CAP_EVENT_TYPE}}EventModel{} // DYNAMIC
	// -----------------------------------------------
	remoteIp, _, err := net.SplitHostPort(r.RemoteAddr)
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}
	body, _ := ioutil.ReadAll(r.Body)
	err = json.Unmarshal(body, &eventModel)
	if err != nil {
		SetHttpError(w, http.StatusBadRequest, err.Error())
		return
	}
	_, err = eventModel.GetEvent() // for validation
	if err != nil {
		SetHttpError(w, http.StatusBadRequest, err.Error())
		return
	}
	db, err := storage.GetDB()
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}
	if eventModel.Id != "" {
		SetHttpError(w, http.StatusBadRequest, "you can't specify 'eventId'")
		return
	}
	eventModel.Sha1 = ""
	jsonByte, _ := json.Marshal(eventModel)
	eventModel.Sha1 = fmt.Sprintf("%x", sha1.Sum(jsonByte))
	eventId := bson.NewObjectId()
	eventModel.Id = eventId
	groupId := userModel.DefaultGroupId
	if eventModel.GroupId != "" {
		if !bson.IsObjectIdHex(eventModel.GroupId) {
			SetHttpError(w, http.StatusBadRequest, "invalid 'groupId'")
			return
			// to avoid panic!
		}
		groupModel, err, internalErr := event_lib.LoadGroupModelByIdHex(
			"groupId",
			db,
			eventModel.GroupId,
		)
		if err != nil {
			if internalErr {
				SetHttpErrorInternal(w, err)
			} else {
				SetHttpError(w, http.StatusBadRequest, err.Error())
			}
			return
		}
		if groupModel.OwnerEmail != email {
			SetHttpError(
				w,
				http.StatusForbidden,
				"you don't have write access this event group",
			)
			return
		}
		groupId = &groupModel.Id
	}
	eventMeta := event_lib.EventMetaModel{
		EventId:      eventId,
		EventType:    eventModel.Type(),
		CreationTime: time.Now(),
		OwnerEmail:   email,
		GroupId:      groupId,
		//AccessEmails: []string{}
	}
	now := time.Now()
	err = db.Insert(event_lib.EventMetaChangeLogModel{
		Time:     now,
		Email:    email,
		RemoteIp: remoteIp,
		EventId:  eventId,
		FuncName: "Add{{.CAP_EVENT_TYPE}}",
		OwnerEmail: &[2]*string{
			nil,
			&email,
		},
	})
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}
	err = db.Insert(event_lib.EventRevisionModel{
		EventId:   eventId,
		EventType: eventModel.Type(),
		Sha1:      eventModel.Sha1,
		Time:      time.Now(),
	})
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}
	// don't store duplicate eventModel, even if it was added by another user
	// the (underlying) eventModel does not belong to anyone
	// like git's blobs and trees
	_, err = event_lib.Load{{.CAP_EVENT_TYPE}}EventModel(
		db,
		eventModel.Sha1,
	)
	if err != nil {
		if db.IsNotFound(err) {
			err = db.Insert(eventModel)
			if err != nil {
				SetHttpError(w, http.StatusBadRequest, err.Error())
				return
			}
		} else {
			SetHttpErrorInternal(w, err)
			return
		}
	}

	eventMeta.FieldsMtime = map[string]time.Time{
		{{ range .EVENT_PATCH_PARAMS }}
			"{{.PARAM}}": now,
		{{ end }}
	}
	{{ if eq .EVENT_TYPE "custom" }}
		for _, ruleModel := range eventModel.Rules {
			eventMeta.FieldsMtime["rules:"+ruleModel.Type] = now
		}
	{{ end }}
	err = db.Insert(eventMeta)
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}
	json.NewEncoder(w).Encode(map[string]string{
		"eventId": eventId.Hex(),
		"sha1":    eventModel.Sha1,
	})
}

func Get{{.CAP_EVENT_TYPE}}(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	userModel := CheckAuthGetUserModel(w, r)
	if userModel == nil {
		return
	}
	email := userModel.Email
	// -----------------------------------------------
	//vars := mux.Vars(&r.Request) // vars == map[] // FIXME
	eventId := ObjectIdFromURL(w, r, "eventId", 0)
	if eventId == nil {
		return
	}
	// -----------------------------------------------
	db, err := storage.GetDB()
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}

	eventMeta, err := event_lib.LoadEventMetaModel(db, eventId, true)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusBadRequest, "event not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}
	if !eventMeta.CanRead(email) {
		SetHttpError(w, http.StatusForbidden, "you don't have access to this event")
		return
	}
	if !settings.ALLOW_MISMATCH_EVENT_TYPE {
		if eventMeta.EventType != "{{.EVENT_TYPE}}" {
			SetHttpError(
				w,
				http.StatusBadRequest,
				fmt.Sprintf(
					"mismatch {eventType}, must be '%s'",
					eventMeta.EventType,
				),
			)
			return
		}
	}

	eventRev, err := event_lib.LoadLastRevisionModel(db, eventId)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusBadRequest, "event not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}

	eventModel, err := event_lib.Load{{.CAP_EVENT_TYPE}}EventModel(
		db,
		eventRev.Sha1,
	)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusInternalServerError, "event snapshot not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}

	eventModel.Id = *eventId
	eventModel.DummyType = eventMeta.EventType  // not "{{.EVENT_TYPE}}"
	eventModel.GroupId = eventMeta.GroupIdHex() // FIXME
	if eventMeta.CanReadFull(email) {
		eventModel.Meta = eventMeta.JsonM()
	}
	json.NewEncoder(w).Encode(eventModel)
}

func Update{{.CAP_EVENT_TYPE}}(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	userModel := CheckAuthGetUserModel(w, r)
	if userModel == nil {
		return
	}
	email := userModel.Email
	// -----------------------------------------------
	eventModel := event_lib.{{.CAP_EVENT_TYPE}}EventModel{} // DYNAMIC
	// -----------------------------------------------
	//vars := mux.Vars(&r.Request) // vars == map[] // FIXME
	eventId := ObjectIdFromURL(w, r, "eventId", 0)
	if eventId == nil {
		return
	}
	// -----------------------------------------------
	body, _ := ioutil.ReadAll(r.Body)
	err := json.Unmarshal(body, &eventModel)
	if err != nil {
		msg := err.Error()
		if strings.Contains(msg, "invalid ObjectId in JSON") {
			msg = "invalid 'eventId'"
		}
		SetHttpError(w, http.StatusBadRequest, msg)
		return
	}
	{{ if eq .EVENT_TYPE "custom" }}
		event, err := eventModel.GetEvent() // for validation and comparing rules
	{{ else }}
		_, err = eventModel.GetEvent() // for validation
	{{ end }}
	if err != nil {
		SetHttpError(w, http.StatusBadRequest, err.Error())
		return
	}
	db, err := storage.GetDB()
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}

	// check if event exists, and has access to
	eventMeta, err := event_lib.LoadEventMetaModel(db, eventId, false)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusBadRequest, "event not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}
	if eventMeta.OwnerEmail != email {
		SetHttpError(w, http.StatusForbidden, "you don't have write access to this event")
		return
	}

	lastEventRev, err := event_lib.LoadLastRevisionModel(db, eventId)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusBadRequest, "event not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}
	lastEventModel, err := event_lib.Load{{.CAP_EVENT_TYPE}}EventModel(
		db,
		lastEventRev.Sha1,
	)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusInternalServerError, "event snapshot not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}

	if eventModel.Id != "" {
		SetHttpError(w, http.StatusBadRequest, "'eventId' must not be present in JSON")
		return
	}
	if eventModel.GroupId != "" {
		SetHttpError(w, http.StatusBadRequest, "'groupId' must not be present in JSON")
		return
	}
	if len(eventModel.Meta) != 0 {
		SetHttpError(w, http.StatusBadRequest, "'meta' must not be present in JSON")
		return
	}
	eventModel.Sha1 = ""
	jsonByte, _ := json.Marshal(eventModel)
	eventModel.Sha1 = fmt.Sprintf("%x", sha1.Sum(jsonByte))

	now := time.Now()

	eventRev := event_lib.EventRevisionModel{
		EventId:   *eventId,
		EventType: eventModel.Type(),
		Sha1:      eventModel.Sha1,
		Time:      now,
	}
	err = db.Insert(eventRev)
	if err != nil {
		SetHttpError(w, http.StatusBadRequest, err.Error())
		return
	}

	// don't store duplicate eventModel, even if it was added by another user
	// the (underlying) eventModel does not belong to anyone
	// like git's blobs and trees
	_, err = event_lib.Load{{.CAP_EVENT_TYPE}}EventModel(
		db,
		eventRev.Sha1,
	)
	if err != nil {
		if db.IsNotFound(err) {
			err = db.Insert(eventModel)
			if err != nil {
				SetHttpError(w, http.StatusBadRequest, err.Error())
				return
			}
		} else {
			SetHttpErrorInternal(w, err)
			return
		}
	}

	{{ range .EVENT_PATCH_PARAMS }}
		// PARAM="{{.PARAM}}", PARAM_TYPE="{{.PARAM_TYPE}}"
		{{ if eq .PARAM "rules" }}
			lastEvent, err := lastEventModel.GetEvent() // for comparing rules
			if err != nil {
				SetHttpErrorInternal(w, err)
				return
			}
			modRuleTypes := event.GetModifiedRuleTypes(&lastEvent)
			if len(modRuleTypes) > 0 {
				eventMeta.FieldsMtime["rules"] = now
				for _, ruleType := range modRuleTypes {
					eventMeta.FieldsMtime["rules:"+ruleType.Name] = now
				}
			}
		{{ else }}
			if !reflect.DeepEqual(
				eventModel.{{.CAP_PARAM}},
				lastEventModel.{{.CAP_PARAM}},
			) {
				eventMeta.FieldsMtime["{{.PARAM}}"] = now
			}
		{{ end }}
	{{ end }}
	err = db.Update(eventMeta) // just for FieldsMtime, is it safe? FIXME
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}

	json.NewEncoder(w).Encode(map[string]string{
		"eventId": eventId.Hex(),
		"sha1":    eventRev.Sha1,
	})
}


func Patch{{.CAP_EVENT_TYPE}}(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	userModel := CheckAuthGetUserModel(w, r)
	if userModel == nil {
		return
	}
	email := userModel.Email
	// -----------------------------------------------
	//vars := mux.Vars(&r.Request) // vars == map[] // FIXME
	eventId := ObjectIdFromURL(w, r, "eventId", 0)
	if eventId == nil {
		return
	}
	// -----------------------------------------------
	body, _ := ioutil.ReadAll(r.Body)
	patchMap := scal.M{}
	err := json.Unmarshal(body, &patchMap)
	if err != nil {
		msg := err.Error()
		if strings.Contains(msg, "invalid ObjectId in JSON") {
			msg = "invalid 'eventId'"
		}
		SetHttpError(w, http.StatusBadRequest, msg)
		return
	}
	db, err := storage.GetDB()
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}

	// check if event exists, and has access to
	eventMeta, err := event_lib.LoadEventMetaModel(db, eventId, false)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusBadRequest, "event not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}
	if eventMeta.OwnerEmail != email {
		SetHttpError(w, http.StatusForbidden, "you don't have write access to this event")
		return
	}

	// do we need the last revision? to compare or what?
	lastEventRev, err := event_lib.LoadLastRevisionModel(db, eventId)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusBadRequest, "event not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}
	eventModel, err := event_lib.Load{{.CAP_EVENT_TYPE}}EventModel(
		db,
		lastEventRev.Sha1,
	)
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}
	{{ if eq .EVENT_TYPE "custom" }}
		lastEvent, err := eventModel.GetEvent()// for comparing rules
		if err != nil {
			SetHttpErrorInternal(w, err)
			return
		}
		rulesModified := false
	{{ end }}
	now := time.Now()
	{{ range .EVENT_PATCH_PARAMS }}
	{
		rawValue, ok := patchMap["{{.PARAM}}"]
		if ok {
			{{ if eq .PARAM "rules" }}
				value, err := event_lib.DecodeMapEventRuleModelList(rawValue)
				if err != nil {
					SetHttpError(
						w,
						http.StatusBadRequest,
						"bad type or value for parameter 'rules': "+err.Error(),
					)
					return
				}
			{{ else }}
				{{ if eq .PARAM_TYPE "int" }}
					// json Unmarshal converts int to float64
					value, typeOk := rawValue.(float64)
				{{ else if eq .PARAM_TYPE "*time.Time" }}
					value, typeOk := rawValue.(string)
				{{ else }}
					value, typeOk := rawValue.({{.PARAM_TYPE}})
				{{ end }}
				if !typeOk {
					SetHttpError(
						w,
						http.StatusBadRequest,
						"bad type for parameter '{{.PARAM}}'",
					)
					return
				}
			{{ end }}
			{{ if eq .PARAM_TYPE "int" }}
				eventModel.{{.CAP_PARAM}} = int(value)
			{{ else if eq .PARAM_TYPE "*time.Time" }}
				timeValue, err := time.Parse(time.RFC3339, value)
				if err != nil {
					SetHttpError(w, http.StatusBadRequest, err.Error())
					return
				}
				eventModel.{{.CAP_PARAM}} = &timeValue
			{{ else }}
				eventModel.{{.CAP_PARAM}} = value
			{{ end }}
			delete(patchMap, "{{.PARAM}}")
			eventMeta.FieldsMtime["{{.PARAM}}"] = now
			{{ if eq .PARAM "rules" }}
				rulesModified = true
			{{ end }}
		}
	}{{ end }}
	if len(patchMap) > 0 {
		for param, _ := range patchMap {
			SetHttpError(
				w,
				http.StatusBadRequest,
				fmt.Sprintf(
					"extra parameter '%s'",
					param,
				),
			)
		}
		return
	}
	{{ if eq .EVENT_TYPE "custom" }}
		event, err := eventModel.GetEvent() // for validation and comparing rules
	{{ else }}
		_, err = eventModel.GetEvent() // for validation
	{{ end }}
	if err != nil {
		SetHttpError(w, http.StatusBadRequest, err.Error())
		return
	}
	{{ if eq .EVENT_TYPE "custom" }}
		if rulesModified {
			for _, ruleType := range event.GetModifiedRuleTypes(&lastEvent) {
				eventMeta.FieldsMtime["rules:"+ruleType.Name] = now
			}
		}
	{{ end }}

	eventModel.Sha1 = ""
	jsonByte, _ := json.Marshal(eventModel)
	eventModel.Sha1 = fmt.Sprintf("%x", sha1.Sum(jsonByte))

	err = db.Insert(event_lib.EventRevisionModel{
		EventId:   *eventId,
		EventType: eventModel.Type(),
		Sha1:      eventModel.Sha1,
		Time:      now,
	})
	if err != nil {
		SetHttpError(w, http.StatusBadRequest, err.Error())
		return
	}
	// don't store duplicate eventModel, even if it was added by another user
	// the (underlying) eventModel does not belong to anyone
	// like git's blobs and trees
	_, err = event_lib.Load{{.CAP_EVENT_TYPE}}EventModel(
		db,
		eventModel.Sha1,
	)
	if err != nil {
		if db.IsNotFound(err) {
			err = db.Insert(eventModel)
			if err != nil {
				SetHttpError(w, http.StatusBadRequest, err.Error())
				return
			}
		} else {
			SetHttpErrorInternal(w, err)
			return
		}
	}
	err = db.Update(eventMeta) // just for FieldsMtime, is it safe? FIXME
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}
	json.NewEncoder(w).Encode(map[string]string{
		"eventId": eventId.Hex(),
		"sha1":    eventModel.Sha1,
	})
}

func Merge{{.CAP_EVENT_TYPE}}(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	userModel := CheckAuthGetUserModel(w, r)
	if userModel == nil {
		return
	}
	email := userModel.Email
	// remoteIp, _, err := net.SplitHostPort(r.RemoteAddr)
	// if err != nil {
	// 	SetHttpErrorInternal(w, err)
	// 	return
	// }
	// -----------------------------------------------
	//vars := mux.Vars(&r.Request) // vars == map[] // FIXME
	eventId := ObjectIdFromURL(w, r, "eventId", 0)
	if eventId == nil {
		return
	}
	// -----------------------------------------------
	inputStruct := struct {
		Event event_lib.{{.CAP_EVENT_TYPE}}EventModel `json:"event"` // DYNAMIC

		LastMergeSha1 string               `json:"lastMergeSha1"`
		FieldsMtime   map[string]time.Time `json:"fieldsMtime"`
	}{}

	body, _ := ioutil.ReadAll(r.Body)
	err := json.Unmarshal(body, &inputStruct)
	if err != nil {
		SetHttpError(w, http.StatusBadRequest, err.Error())
		return
	}
	db, err := storage.GetDB()
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}
	// if inputStruct.Event.DummyType == "" {
	// 	SetHttpError(w, http.StatusBadRequest, "missing 'eventType'")
	// 	return
	// }
	if inputStruct.Event.Id == "" {
		SetHttpError(w, http.StatusBadRequest, "missing 'eventId'")
		return
	}
	// FIXME: LastMergeSha1 can be empty?
	if inputStruct.LastMergeSha1 == "" {
		SetHttpError(w, http.StatusBadRequest, "missing 'lastMergeSha1'")
		return
	}
	inputEventModel := &inputStruct.Event
	if inputEventModel.Id.Hex() != eventId.Hex() {
		SetHttpError(w, http.StatusBadRequest, "mismatch 'event.id'")
		return
	}

	eventMeta, err := event_lib.LoadEventMetaModel(db, eventId, true)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusBadRequest, "event not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}
	if eventMeta.OwnerEmail != email {
		SetHttpError(w, http.StatusForbidden, "you don't own this event")
		return
	}

	lastRevModel, err := event_lib.LoadLastRevisionModel(db, eventId)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusBadRequest, "event not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}
	parentEventModel, err := event_lib.Load{{.CAP_EVENT_TYPE}}EventModel(db, inputStruct.LastMergeSha1)
	if err != nil {
		if db.IsNotFound(err) {
			SetHttpError(w, http.StatusBadRequest, "invalid lastMergeSha1: revision not found")
		} else {
			SetHttpErrorInternal(w, err)
		}
		return
	}
	lastEventModel, err := event_lib.Load{{.CAP_EVENT_TYPE}}EventModel(db, lastRevModel.Sha1)
	if err != nil {
		SetHttpErrorInternal(w, err)
		return
	}
	fmt.Println(parentEventModel)
	fmt.Println(lastEventModel)

	// performing a 3-way merge
	// C <== parentEventModel	<== The common ancestor (last merge for this client)
	// A <== inputEventModel	<== The input (client's latest) data
	// B <== lastEventModel		<== The current (server's latest) data
	now := time.Now()
	{{ range .EVENT_PATCH_PARAMS }}
	func(){
		// PARAM="{{.PARAM}}", PARAM_TYPE="{{.PARAM_TYPE}}"
		inputValue := inputEventModel.{{.CAP_PARAM}}
		lastValue := lastEventModel.{{.CAP_PARAM}}
		if reflect.DeepEqual(inputValue, lastValue) {
			return
		}
		parentValue := parentEventModel.{{.CAP_PARAM}}
		if reflect.DeepEqual(parentValue, lastValue) {
			return
		}
		if reflect.DeepEqual(parentValue, inputValue) {
			lastEventModel.{{.CAP_PARAM}} = inputValue
			eventMeta.FieldsMtime["{{.PARAM}}"] = now
			return
		}
		// Now we have a conflict
		if inputStruct.FieldsMtime["{{.PARAM}}"].After(eventMeta.FieldsMtime["{{.PARAM}}"]) {
			lastEventModel.{{.CAP_PARAM}} = inputValue
			eventMeta.FieldsMtime["{{.PARAM}}"] = now
			return
		}
	}()
	{{ end }}
	// err = db.Update(eventMeta) // just for FieldsMtime, is it safe? FIXME
	// if err != nil {
	// 	SetHttpErrorInternal(w, err)
	// 	return
	// }


}